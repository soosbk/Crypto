#include<stdio.h>

//128bit

#define round_num 10
#define size1 4



/*
0_2. key_f fun
*/

void t_t(unsigned char output[][size1])
{

	int i = 0x00;
	int j = 0x00;
	unsigned char sample[size1][size1] = { {0x00,}, };

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			sample[j][i] = output[i][j];
		}
	}

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			output[i][j] = sample[i][j];
		}
	}
}


/*
0_3. sbox key f
*/

//ok!!!
void sbox0(unsigned char input[])
{
	unsigned char s_box[16][16] = {
		{0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76},
		{0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0},
		{0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15},
		{0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75},
		{0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84},
		{0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf},
		{0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8},
		{0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2},
		{0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73},
		{0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb},
		{0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79},
		{0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08},
		{0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a},
		{0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e},
		{0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf},
		{0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16}
	};

	int i = 0x00;
	unsigned char rows[size1] = { 0x00, };
	unsigned char cols[size1] = { 0x00, };
	for (i = 0; i < size1; i++)
	{
		rows[i] = input[i] >> size1;
		cols[i] = input[i] << size1;
		cols[i] = cols[i] >> size1;

	}



	for (i = 0; i < size1; i++)
	{
		input[i] = s_box[rows[i]][cols[i]];
	}




}

/*
0. key schedule
*/

void F(unsigned char key2[][4], int round)
{
	int i = 0x00;
	unsigned char bonus[4] = { 0x00, };
	unsigned char Round[round_num][4] = 
	{ {0x01,0x00,0x00,0x00},
		{0x02,0x00,0x00,0x00},
		{0x04,0x00,0x00,0x00},
		{0x08,0x00,0x00,0x00},
		{0x10,0x00,0x00,0x00},
		{0x20,0x00,0x00,0x00},
		{0x40,0x00,0x00,0x00},
		{0x80,0x00,0x00,0x00},
		{0x1b,0x00,0x00,0x00},
		{0x36,0x00,0x00,0x00} };
	int j = 0x00;
	
	for (i = 0; i < 4; i++)
	{
		bonus[i] = key2[(1 + i) % 4][3];
		
	}
	
	sbox0(bonus);


	//R함수~~~~

	for (i = 0; i < size1; i++)
	{
		bonus[i] = bonus[i] ^ Round[round][i];

	}

	
	for (i = 0; i < size1; i++)
	{
		for (j = 0; j < size1; j++)
		{
			if (i == 0)
				key2[j][i] = key2[j][i] ^ bonus[j];
			else
			{
				key2[j][i] = key2[j][i] ^ key2[j][i-1];
			}
			
		}
	}
	




}




/*
1. addroundkey
*/
void addroundkey(unsigned char pt[][size1], unsigned char key[][size1])
{
	int i = 0x00;
	int j = 0x00;

	for (i = 0; i < size1; i++)
	{
		for (j = 0; j < size1; j++)
		{
			pt[i][j] = pt[i][j] ^ key[i][j];
		}
	}



}

/*
2_2. 1차원 -> 2차원 4x4로 바꿔주는 함수
*/


void one_to_two(unsigned char input[], unsigned char output[][4])
{
	int i = 0x00;
	int j = 0x00;
	int k = 0x00;
	
	for (i = 0; i < size1; i++)
	{
		for (j = 0; j < size1; j++)
		{
			output[j][i] = input[k++];
		}
	}

}






/*
2. subbytes
*/


void subbytes(unsigned char input[][4])
{
	unsigned char s_box[16][16] = {
		{0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76},
		{0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0},
		{0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15},
		{0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75},
		{0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84},
		{0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf},
		{0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8},
		{0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2},
		{0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73},
		{0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb},
		{0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79},
		{0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08},
		{0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a},
		{0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e},
		{0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf},
		{0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16}
	};

	int i = 0x00;
	int j = 0x00;
	unsigned char rows[16] = { 0x00, };
	unsigned char cols[16] = { 0x00, };
	for (i = 0; i < size1; i++)
	{


		for (j = 0; j < size1; j++)
		{
			rows[(i * 4) + j] = (input[i][j]) >> size1;
			//printf("[%d] %x", (i * 4) + j,rows[(i * 4) + j]);
			cols[(i * 4) + j] = ((input[i][j]) << size1);
			cols[(i * 4) + j] = cols[(i * 4) + j] >> size1;
			cols[(i * 4) + j] = cols[(i * 4) + j] & (0x0f);
			//printf("and %x\n", cols[(i * 4) + j]);

		}


	}

	int k = 0x00;

	for (i = 0; i < size1; i++)
	{
		for (j = 0; j < size1; j++)
		{


			input[i][j] = s_box[rows[k]][cols[k]];
			k += 1;
		}
	}






}






/*
3. shiftrows
*/
void shiftrows(unsigned char in[][size1])
{
	int i = 0x00;
	int j = 0x00;
	unsigned char kep[size1] = { 0x00, };

	for (i = 0; i < size1; i++)
	{
		for (j = 0; j < size1; j++)
		{
			kep[j] = in[i][(i + j) % size1];

		}
		for (j = 0; j < size1; j++)
		{
			in[i][j] = kep[j];
		}
	}

}

/*
4_2.행렬 fun
*/

unsigned char gf_fun(unsigned char box, unsigned char pt)
{
	int i;
	unsigned char output = 0x00;

	if (box == 0x01)
		output = output ^ pt;

	else if (box == 0x02)
	{
		if (pt & 0x80)
			output = output ^ ((pt << 1) ^ 0x1B);
		else
			output = output ^ (pt << 1);
	}

	else if (box == 0x03)
	{
		if (pt & 0x80)
			output=output^pt+ output ^ ((pt << 1) ^ 0x1B);
		else
			output = output ^ pt + output ^ (pt << 1);
	}

	return output;

}

/*
4. mixcolums
*/


void mixcolumn(unsigned char input[][size1])
{
	int i = 0x00;
	int j = 0x00;
	int k = 0x00;

	unsigned char box[size1][size1] =
	{ {0x02,0x03,0x01,0x01},
		{0x01,0x02,0x03,0x01},
		{0x01,0x01,0x02,0x03},
		{0x03,0x01,0x01,0x02} };

	unsigned char sample[size1][size1] = { {0x00,}, };



	for (i = 0; i < size1; i++)
	{
		for (j = 0; j < size1; j++)
		{
			for (k = 0; k < size1; k++)
			{
				sample[i][j] ^= gf_fun(box[i][k], input[k][j]);
				

			}
			
		}


	}

	for (i = 0; i < size1; i++)
	{
		for (j = 0; j < size1; j++)
		{
			input[i][j] = sample[i][j];
		}
	}


}

/* TEST CASE
unsigned char key[size1][size1] = { {0x00,0x04,0x08,0x0c},{0x01,0x05,0x09,0x0d},{0x02,0x06,0x0a,0x0e},{0x03,0x07,0x0b,0x0f} };
unsigned char plaintext[size1][size1] = {{0x00,0x44,0x88,0xcc},{0x11,0x55,0x99,0xdd},{0x22,0x66,0xaa,0xee},{0x33,0x77,0xbb,0xff}};		
*/

int main()
{
	int round = 0x00;
	unsigned char key[size1][size1] = { 0x00, };
	unsigned char pt_input[17] = { 0x00, };  //1차원

	unsigned char plaintext[size1][size1] = { 0x00, };   //2차원
	int i = 0x00;
	unsigned char key_input[17] = { 0x00, };
	unsigned char ciphertext[17] = { 0x00, };
	printf("input your plaintext: ");
	gets(pt_input);  //16바이트의 문자열 +\0값
	//Two One Nine Two
	printf("input your key: ");
	gets(key_input);   //16바이트의 문자열 +\0값
	// Thats my Kung Fu
	one_to_two(pt_input, plaintext);
	one_to_two(key_input, key);
	int j = 0x00;
	
	addroundkey(plaintext, key);
	
	for (round = 1; round < round_num; round++)
	{
		subbytes(plaintext);
		
		shiftrows(plaintext);
		
		mixcolumn(plaintext);
		
		F(key, round - 1);
		addroundkey(plaintext, key);
		
	}
	subbytes(plaintext);
	shiftrows(plaintext);
	F(key, 9);
	addroundkey(plaintext, key);

	for (i = 0; i < 16; i++)
	{
		ciphertext[i] = plaintext[i % 4][i / 4];
		printf("%X ", ciphertext[i]);
	}




}
